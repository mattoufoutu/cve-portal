# -*- coding: utf-8 -*-
import warnings
from urlparse import urljoin
from issue_tracker import IssueTracker, Issue, IssueTrackerProcessingError

import requests


class GitlabAPIError(Exception):
    pass


class GitlabAPI(object):
    api_url = '/api/v3'

    def __init__(self, gitlab_url, api_token):
        self.url = gitlab_url.rstrip('/') + self.api_url
        self.token = api_token
        self.headers = {'PRIVATE-TOKEN': self.token}

    def _request(self, http_method, endpoint, url_args=None, data=None):
        url = self.url + endpoint
        http_method = http_method.lower()
        method = getattr(requests, http_method, 'get')
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            resp = method(url, params=url_args, data=data, headers=self.headers)
        if resp.status_code not in (200, 201):
            messages_section = resp.json()['message']
            if isinstance(messages_section, dict):
                for message_title in messages_section:
                    for message_body in messages_section[message_title]:
                        warnings.warn('GitlabAPI Error: %s %s' % (message_title, message_body), RuntimeWarning)
            else:
                warnings.warn('GitlabAPI Error: %s' % messages_section, RuntimeWarning)
            raise GitlabAPIError('An error occured, see console warnings for details')
        return resp.json()

    def get_project(self, name):
        avail_projects = self._request('get', '/projects')
        for project in avail_projects:
            if project['path_with_namespace'] == name:
                return project
        return None

    def get_issues(self, project_id):
        issues = self._request('get', '/projects/%d/issues' % project_id)
        return issues

    def create_issue(self, project_id, title, **kwargs):
        optional_params = ['description', 'assignee_id', 'milestone_id', 'labels']
        params = {'title': title}
        for opt_param in optional_params:
            if opt_param in kwargs:
                params[opt_param] = kwargs[opt_param]
        new_issue = self._request('post', '/projects/%d/issues' % project_id, data=params)
        return new_issue


class GitlabTracker(IssueTracker):
    required_kwargs = ['tracker_url', 'api_token', 'repository']

    def __init__(self, **kwargs):
        super(GitlabTracker, self).__init__(**kwargs)
        self.url = kwargs['tracker_url']
        self.token = kwargs['api_token']
        self.gitlab = GitlabAPI(self.url, self.token)
        self.project = self.gitlab.get_project(kwargs['repository'])
        self.issues_url = '/'.join([self.url, kwargs['repository'], 'issues/'])

    @property
    def issues(self):
        try:
            tracker_issues = self.gitlab.get_issues(self.project['id'])
        except GitlabAPIError:
            return
        for tracker_issue in tracker_issues:
            if tracker_issue['state'] != 'opened':
                continue
            try:
                cpe, cve, cvss = tracker_issue['title'].split('|')
            except ValueError:
                raise IssueTrackerProcessingError('Issue title format not recognized: %s' % tracker_issue['title'])
            issue_url = urljoin(self.issues_url, str(tracker_issue['id']))
            issue = Issue(
                self,
                tracker_issue['id'],
                issue_url,
                cpe,
                cve,
                cvss,
            )
            yield issue

    def open_issue(self, notification, cve):
        return None
